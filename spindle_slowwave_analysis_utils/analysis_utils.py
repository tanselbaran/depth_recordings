"""
Created on Wednesday, 31st of July 2019

author: Mert Unsal

Contains the functions for analyzing electrophysiological data, specifically finding out if there's a modulation between spindle, slow waves and spike trains.
"""

import numpy as np
from matplotlib import pyplot as plt
from scipy import signal
from scipy import fftpack
import statistics as stat

'''
This function takes peak indexes and total length of data as input and returns the spike train.
'''

def get_spike_train(peak_index, length):
    spike_train = np.zeros(length)
    for i in peak_index:
        spike_train[i] = 1
    return spike_train

'''
This function takes frequency, number of data points, sampling frequency, and amplitude (optional, 1 if not specified) as input and returns the intended sine_wave
'''

def generate_sinwave(freq, len_data, fs, amplitude = 1):
    ts = 1 / fs
    sin_index = np.arange(0,len_data)
    var = 2 * np.pi * freq * sin_index * ts
    sin_wave = amplitude * np.sin(var)
    return sin_wave

'''
This function takes 2 frequencies, number of data points, sampling frequency, and amplitude (optional, 1 if not specified) as input and returns
the function f = A * sin(f1 x) * sin(f2 *x) of lenght len_data
'''

def generate_sinsinwave(freq_sin0, freq_sin1, len_data, fs, amplitude = 1):
    ts = 1 / fs
    index = np.arange(len_data)
    sin0_var = 2 * np.pi * freq_sin0 * index * ts
    sin1_var = 2 * np.pi * freq_sin1 * index * ts
    sinsin_wave = amplitude * np.sin(sin0_var) * np.sin(sin1_var)
    return sinsin_wave

'''
This function takes spike_train, its sampling rate, a sin wave frequency, and phase (in radians) interval as input. It returns an histogramic data for spike_train using phase intervals as bins.
It is required data the sine_wave and the spike_train are of same size. It is assumed that 2 pi is divisible by the phase. The array generated in this function will be inserted in
plotting functions to plot bar charts accordingly.
'''

def phase_hist(spike_train, freq_sin, phase, fs):
    arr = [[],[]] # the second will contain bins and first will contain heights

    bin_range =  (2 * np.pi) / phase

    if float(int(bin_range)) != bin_range:
        raise ValueError("2 pi should be divisible by the phase")

    for i in range( int(bin_range)):
        arr[1].append(round(i * phase * (180 / np.pi)))

    for i in range(int(bin_range)):
        arr[0].append(0)

    data_phase = int( (fs * phase) / (2 * np.pi * freq_sin) )
    ind = 0
    for data in spike_train:
        if data == 1:
            flag = 0
            normalized_phase = ind * 360 * freq_sin * (1/fs)
            normalized_phase -= int(normalized_phase/360) * 360
            for bin in arr[1]:
                if (normalized_phase > bin) and (normalized_phase < (bin + round(phase * (180 / np.pi)) ) ):
                    arr[0][flag] += 1
                    break
                flag += 1
        ind += 1

    return arr

'''
This function takes the array generated by the phase_hist function and the phase of the bins to generate a polar bar chart of the spike train.
'''

def plot_polarbarchart(arr, phase):
    degree = round(phase * (180/np.pi))
    theta = []
    start = phase / 2
    for i in range(len(arr[0])):
        theta.append(start + i * phase)

    radii = np.asarray(arr[0])
    width = phase
    colors = plt.cm.viridis(radii / 10.)
    ax = plt.subplot(111, projection='polar')
    ax.bar(theta, radii, width=width, bottom=0.0, color=colors, alpha=0.5)
    plt.title("Phase Histogram (Phase = {0})".format(degree))
    plt.show()

'''
This function takes the array generated by the phase_hist function and the phase of the bins to generate a standart bar chart of the spike train.
'''

def plot_barchart(arr, phase):
    degree = round(phase * (180/np.pi))
    plt.title("Phase Histogram (Phase = {0})".format(degree))
    plt.xlabel("Phase")
    plt.ylabel("Spike Number")
    width = degree - degree/10
    plt.bar(arr[1], arr[0], width = width)
    xticks = np.arange(len(arr[0])) * degree
    plt.xticks(xticks, arr[1])
    plt.show()

'''
This function takes an array and its sampling frequency to generate the frequency domain using Fourier Transform. It is assumed that the the function is periodic.
To plot the frequency domain you can use plot_spectrum function. The output is the relative values of the frequencies (<1) and frequency range in an array like this
output type: [relative_values, frequency range]
'''

def get_spectrum(y, fs):
    n = len(y)
    k = np.arange(n)
    T = n/fs
    frq = k/T
    frq = frq[range(int(n/2))]

    Y = fftpack.fft(y)/n
    Y = Y[range(int(n/2))]
    Y = abs(Y)

    return [Y, frq]

'''
This function takes the output of find_spectrum function to plot frequency domain using Fourier Transform. Intended frequency range can be entered as an input
to see that range closely in the graph but it is not required.
'''

def plot_spectrum(Y, frq , freq_range = [0,0]):
    plt.plot(frq, Y, 'r')
    plt.xlabel('Freq (Hz)')
    plt.ylabel('F(freq)')
    plt.title("Frequency Domain")

    if freq_range == [0,0]:
        plt.show()

    else:
        plt.xlim(freq_range[0],freq_range[1])
        plt.show()


'''
This function takes a signal array and the coefficient for determining minimum heights of the peaks. The coefficient is multiplied by the base noise in order to find the
minimum peak height. The function returns aN array which includes peak heights and indexes in scipy format.
'''

def find_peaks(signal_array, coeff, spike = True):
    height = np.sqrt(stat.variance(signal_array[:int(len(signal_array) / 10)]  )) * coeff
    # signal is multiplied by -1 (we only want to find negative peaks in recording because positive peaks are followed after them)
    if spike:
        peaks = signal.find_peaks(np.multiply(signal_array, -1), height)
        return peaks
    else:
        peaks = signal.find_peaks(signal_array, height)
        return peaks

'''
This function takes the time range, time, and spike_train as input to plot the spike train in a specific time range.
'''

def plot_spike_train(spike_train, time, time_limit):
    plt.title("Spike Train")
    plt.xlabel("Time (s)")
    plt.ylabel("Spike Activity")
    plt.xlim(time_limit)
    plt.plot(time, spike_train, color='b')
    plt.show()


'''
This function takes a wave as input and returns the envelope wave using Hilbert Transform.
'''

def get_envelope_wave(wave):
    return np.abs(signal.hilbert(wave))

'''
This function takes a frequency spectrum, limit relative power and frequency range and returns the major components of frequency as an array. Output of the get_spectrum function can be used
in this function to find major frequencies. The function outputs the strongest frequency components that have relative power higher than the limit relative power, as an array.
It is assumed that spectrum is normalized.
'''

def get_major_freqs(spectrum, freq_range, limit):
    major_freqs = [[],[]]
    peaks = signal.find_peaks(spectrum, limit)[0]
    for index in peaks:
        major_freqs[0].append(freq_range[index])
        major_freqs[1].append(spectrum[index])
    return major_freqs

'''
This function takes major frequencies of a spectrum and outputs the major frequency component.  The input array of major frequencies should be in the same format
with the output of get_major_freqs function. It returns the smallest frequency if there are several major frequencies with same relative power.
'''
#returns the smallest frequency if there are several major frequencies
def get_major_freq(major_freqs):
    major_freq = 0
    rel_value = 0
    index = 0
    for relvalue in major_freqs[1]:
        if relvalue > rel_value:
            major_freq = major_freqs[0][index]
            rel_value = relvalue
        index += 1
    return major_freq

'''
This function is for plotting the raw data in a specific time limit, taking data, time, xlabel, ylabel, title, and time limit as input.
'''

def plot_data(data, times, xlabel, ylabel, title, time_limit):
    fig, ax = plt.subplots(1, 1)
    plt.plot(times, data, lw=1.5, color='k')
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.xlim(time_limit)
    plt.title(title)
    plt.show()
